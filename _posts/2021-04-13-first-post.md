---
title: "python-append를 재정의하는것이 더 빠를까?"
excerpt: "문제풀이"

categories:
  - Blog
tags:
  - algorithm
  - python
last_modified_at: 2021-04-13 20:00:00-05:00

comments : true
---
![image-20210413200526442](/assets/images/image-20210413200526442.png)

오늘도 백준 풀다가 잘 안풀려서 게시글 보는중에 고개를 갸우뚱하게 만드는 문구를 보았다.

반복문에서 append를 사용하기전에 함수를 `append = 배열명.append`로 변경해서 반복문 돌리면 더 빠르다는 말이다.

인간입장에서는 쓸데없는 짓을 한번 하는 셈인데 이게 왜 더빠르지?? 싶어서 바로 테스트해보았다.



```python
#1
import time

start = time.time()
p = []
for i in range(100000000):
    p.append(i)
print(time.time() - start)
#결과:12.082726240158081
```

임의의 list를 만들어서 append를 통해 값을 계속 추가해주었고,

이를 1억번 시행하였다.

걸린 시간은 12초 쯤걸렸다.

```python
#2
import time

start = time.time()
p = []
append = p.append
for i in range(100000000):
    append(i)
print(time.time() - start)
#결과:9.028038501739502
```

그리고 두번째는 반복문 시행 전`append = p.append`를 추가하여 반복문 내부에는 `append()`만 입력하여 테스트하였다.

그 결과 적게는 0.1~4,0초나 줄어들었다.(이왜진?;;)

1억이 아닌 1천만번이면 걸리는 시간과 두 시간의 차이가 1/10쯤 줄어든다

조금더 객관적인 자료를 구하고자 10번 반복하여 시간차를 구해보았다.

```python
import time

for g in range(10):
    start = time.time()
    p = []
    for i in range(100000000):
        p.append(i)
    time1 = time.time() - start
    start = time.time()
    p = []
    append = p.append
    for i in range(100000000):
        append(i)
    time2 = time.time() - start
    print("#{} {}".format(g, time1 - time2))#시간이 더 걸리는 첫번째 시간에서 두번째 시간 뺄셈

```

```
#0 2.101485013961792
#1 1.7293903827667236
#2 1.0440609455108643
#3 1.1732652187347412
#4 1.1222538948059082
#5 1.1522495746612549
#6 1.1672539710998535
#7 1.1572520732879639
#8 1.2402706146240234
#9 1.1292738914489746
```

약 10번의 테스트 결과 1초~2초정도 차이가난다고 볼수있다.

원리가 궁금해서 담당 교수님께 질문드렸고, 교수님도 흥미롭게 여기셨다.

교수님은 pypy로 테스트를 하셨고

```
1천개
time : 0.21770596504211426
time : 0.15857601165771484

1억개
time : 1.8786849975585938
time : 2.035144090652466
```

1억번 반복에서는 오히려 후자가 더 느리고, 천번 반복에서는 전자가 더 빠르다는(??)

납득이 잘 되지않는 결과가 발생하였다😥

백준 알고리즘문제 제출할때 pypy 혹은 python둘중 하나를 선택할 수 있는데,

어떻게 코딩하느냐에 따라 속도차이가 달라진다는것이다.



물론 1억번,1천만번 append를 해야하는 문제는 풀지않을거라 생각하기에

더 깊게 파고들지는 않기로 하였다.

정말 의문이 드는 테스트였다;;